- IO多路复用
- slect

## 阻塞式socket与非阻塞式socket

### 读(recv/read/msgrcv)

读的本质来说其实不能是读,在实际中, 具体的接收数据不是由这些调用来进行,是由于系统底层自动完成的。read 也好,recv 也好只负责把数据从底层缓冲copy 到我们指定的位置.

对于读来说(read, 或者recv) ：

**阻塞情况下：**

在阻塞条件下，read/recv/msgrcv的行为：

1. 如果没有发现数据在网络缓冲中会一直等待

2. 当发现有数据的时候会把数据读到用户指定的缓冲区，但是如果这个时候读到的数据量比较少，比参数中指定的长度要小，read 并不会一直等待下去，而是立刻返回。

read 的原则：是数据在不超过指定的长度的时候有多少读多少，没有数据就会一直等待。

所以一般情况下::我们读取数据都需要采用循环读的方式读取数据，因为一次read 完毕不能保证读到我们需要长度的数据，

read 完一次需要判断读到的数据长度再决定是否还需要再次读取。

**非阻塞情况下::**

​    在非阻塞的情况下，read 的行为::

    1. 如果发现没有数据就直接返回
       2. 如果发现有数据那么也是采用有多少读多少的进行处理，所以read 完一次需要判断读到的数据长度再决定是否还需要再次读取。


对于读而言：阻塞和非阻塞的区别在于没有数据到达的时候是否立刻返回．

### 写(send/write/msgsnd)

**写的本质**也不是进行发送操作,而是把用户态的数据copy 到系统底层去,然后再由系统进行发送操作,send，write返回成功，只表示数据已经copy 到底层缓冲,而不表示数据已经发出,更不能表示对方端口已经接收到数据。

对于write(或者send)而言：

**阻塞情况下：**

在阻塞的情况下，是会一直等待，直到write 完，全部的数据再返回．这点行为上与读操作有所不同。

**原因：**读，究其原因主要是读数据的时候我们并不知道对端到底有没有数据，数据是在什么时候结束发送的，如果一直等待就可能会造成死循环，所以并没有去进行这方面的处理；写，而对于write, 由于需要写的长度是已知的，所以可以一直再写，直到写完．不过问题是write 是可能被打断吗，造成write 一次只write 一部分数据, 所以write 的过程还是需要考虑循环write, 只不过多数情况下一次write 调用就可能成功。

**非阻塞写的情况下：**

非阻塞写的情况下，是采用可以写多少就写多少的策略．与读不一样的地方在于，有多少读多少是**由网络发送的那一端是否有数据传输到**为标准，但是对于可以写多少是**由本地的网络堵塞情况**为标准的，在网络阻塞严重的时候，网络层没有足够的内存来进行写操作，这时候就会出现写不成功的情况，阻塞情况下会尽可能(有可能被中断)等待到数据全部发送完毕， 对于非阻塞的情况就是一次写多少算多少,没有中断的情况下也还是会出现write 到一部分的情况。









