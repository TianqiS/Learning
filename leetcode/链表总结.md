### 链表常用思路总结

- 快慢指针

- 旋转变成二叉树(一般在多级链表中使用)

- 旋转链表解法(61)：
  1. 将链表变成一个环
  2. 之后再把环在需要断开的位置断开
  3. 找到新的链表的头结点
  
- 143题重排列表

  > 给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
  > 将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…
  >
  > 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换

  解题思路： 

  1. 从中点拆分链表，分为前后两个链表，之后再交替插入组成新的链表

  2. 递归

     如果我们的递归函数能够返回当前头元素对应的尾元素，并且将头元素和尾元素之间的链表按要求完成，那就变得简单了。

     

     如上图，我们只需要将 head 指向 tail，tail 指向处理完的链表头即可。

     

     然后我们把之前的 tail.next 返回就是外层 head 对应的 tail 了。

     递归出口的话，如果只有一个节点，那么我们只需要将 head.next 返回。

     递归出口的话，如果只有一个节点，那么我们只需要将 head.next 返回。

     ```java
     if (len == 1) {
         ListNode outTail = head.next;
         head.next = null;
         return outTail;
     }
     ```

     如果是两个节点，我们需要将 head.next.next 返回。

     ```java
     if (len == 2) {
         ListNode outTail = head.next.next;
         head.next.next = null;
         return outTail;
     }
     ```

     然后总体的代码就是下边的样子

     ```java
     public void reorderList(ListNode head) {
     
         if (head == null || head.next == null || head.next.next == null) {
             return;
         }
         int len = 0;
         ListNode h = head;
         //求出节点数
         while (h != null) {
             len++;
             h = h.next;
         }
     
         reorderListHelper(head, len);
     }
     
     private ListNode reorderListHelper(ListNode head, int len) {
         if (len == 1) {
             ListNode outTail = head.next;
             head.next = null;
             return outTail;
         }
         if (len == 2) {
             ListNode outTail = head.next.next;
             head.next.next = null;
             return outTail;
         }
         //得到对应的尾节点，并且将头结点和尾节点之间的链表通过递归处理
         ListNode tail = reorderListHelper(head.next, len - 2);
         ListNode subHead = head.next;//中间链表的头结点
         head.next = tail;
         ListNode outTail = tail.next;  //上一层 head 对应的 tail
         tail.next = subHead;
         return outTail;
     }
     ```

     

     