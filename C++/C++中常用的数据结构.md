### C++中的容器

#### 容器的种类

1. 顺序容器

   顺序容器的元素排列次序与元素值无关，而是由元素添加到容器里的次序决定。常见的顺序容器包括：vector(向量)、list（列表）、deque（队列）

2. 关联容器

   关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。

   关联容器包括：map（集合）、set（映射）、multimap（多重集合）、multiset（多重映射）

3. 容器适配器

   容器适配器，其就是将不适用的序列式容器（包括 vector、deque 和 list）变得适用。即通过封装某个序列式容器，并重新组合该容器中包含的成员函数，使其满足某些特定场景的需要。

   > 容器适配器本质上还是容器，只不过此容器模板类的实现，利用了大量其它基础容器模板类中已经写好的成员函数。当然，如果必要的话，容器适配器中也可以自创新的成员函数。

   STL中的容器适配器及其基础容器

   <img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk48v8yaigj30tu0v0n1i.jpg" alt="截屏2020-10-27 下午10.08.13" style="zoom:50%;" />

   C++中queue和deque的区别

   deque相当于一个双端队列，queue相当于普通的队列

---



1. vector

   - 定义：向量（Vector）是一个封装了**动态大小数组**的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。

   - 容器特性：

     1. 顺序序列

     2. 动态数组

        支持对序列中的任意元素进行快速直接访问，提供了在序列末尾相对快速地添加/删除元素的操作

     3. 能够感知内存分配器的(Allocator-aware)

        容器使用一个内存分配器对象来动态地处理它的存储需求

   - 常用接口：

     - `void push_back(const T& x)` :向量尾部增加一个元素X
     - `void pop_back()`: 删除向量中最后一个元素
     - `iterator begin()`:返回向量头指针，指向第一个元素
     - `iterator end()`:返回向量尾指针，指向向量最后一个元素的下一个位置
     - `int size() const`: 返回向量中元素个数
   
2. stack
   
3. set容器(**会自动排序**)

   和 map、multimap 容器不同，使用 set 容器存储的各个键值对，**要求键 key 和值 value 必须相等**

   举个例子，如下有 2 组键值对数据：

   ```
   {<'a', 1>, <'b', 2>, <'c', 3>}
   {<'a', 'a'>, <'b', 'b'>, <'c', 'c'>}
   ```

   显然，第一组数据中各键值对的键和值不相等，而第二组中各键值对的键和值对应相等。对于 set 容器来说，只能存储第 2 组键值对，而无法存储第一组键值对。

   基于 set 容器的这种特性，当使用 set 容器存储键值对时，只需要为其提供各键值对中的 value 值（也就是 key 的值）即可。仍以存储上面第 2 组键值对为例，只需要为 set 容器提供 {'a','b','c'} ，该容器即可成功将它们存储起来。

   map、multimap 容器都会自行根据键的大小对存储的键值对进行排序，set 容器也会如此，只不过 set 容器中各键值对的键 key 和值 value 是相等的，根据 key 排序，也就等价为根据 value 排序。

   另外，使用 set 容器存储的各个元素的值必须各不相同。更重要的是，从语法上讲 set 容器并没有强制对存储元素的类型做 const 修饰，即 set 容器中存储的元素的值是可以修改的。但是，C++ 标准为了防止用户修改容器中元素的值，对所有可能会实现此操作的行为做了限制，使得在正常情况下，用户是无法做到修改 set 容器中元素的值的

   > 对于初学者来说，切勿尝试直接修改 set 容器中已存储元素的值，这很有可能破坏 set 容器中元素的有序性，最正确的修改 set 容器中元素值的做法是：先删除该元素，然后再添加一个修改后的元素。

4. map容器

   - map容器的初始化方法

     1. 直接赋值法

        ```c++
        map<string, int> m1;
        m1["def"] = 2;
        ```

     2. 用`insert`添加

        ```c++
        map<string, int> m2;
        m2.insert({"abc", 1});
        //其他形式
        m2.insert(make_pair(string("def"), 2));
        m2.insert(pair<string, int>(string("ghi"), 3));
        ```

     3. 列表初始化

        ```c++
        map<string, int> m3 = {
          {"string", 1},
          {"sec", 2},
          {"trd", 3}
        }
        ```

        注：列表初始化适用于c++11和以上的版本，低于11的版本则无法使用

   - 当插入一个key但是不指定value时

     如果需要插入一个key并且不指定value，可以直接用下面这种写法，看起来不是一个表达式，不过map对“[]”进行了重载，本质上仍然是表达式，其含义是如果存在该变量则直接返回对应value，如果不存在则增加该key值并自动初始化为0

     ```c++
     map<string, int> a;
     a["new"];
     ```

     - 不过需要注意的是，如果value类型为数型，即使像上面一样没有进行赋值操作，也一般会默认赋值为——0

     - 如果value是string或char类型，则默认为空，没有默认值，因此，string或char可以用列表初始化进行不给value赋值的添加key，如下面的代码所示：

       ```c++
       string<string,string> m5 = {
           {"first",""}, {"second",""}
           {"third",""}, {"fourth",""}
       };
       ```

5. `unordered_map` 哈希表[原文](https://www.sczyh30.com/posts/C-C/cpp-stl-hashmap/)

   -  与`map`的区别

     STL中，`map` 对应的数据结构是 **红黑树**。红黑树是一种近似于平衡的二叉查找树，里面的数据是有序的。在红黑树上做查找操作的时间复杂度为 **O(logN)**。而 `unordered_map` 对应 **哈希表**，哈希表的特点就是查找效率高，时间复杂度为常数级别 **O(1)**， 而额外空间复杂度则要高出许多。所以对于需要高效率查询的情况，使用 `unordered_map` 容器。而如果对内存大小比较敏感或者数据存储要求有序的话，则可以用 `map` 容器。

6. `unordered_set` [原文](http://c.biancheng.net/view/7250.html)

   unordered_set 容器，可直译为“无序 set 容器”，即 unordered_set 容器和 set 容器很像，唯一的区别就在于 set 容器会自行对存储的数据进行排序，而 unordered_set 容器不会。   

   总的来说，unordered_set 容器具有以下几个特性：

   1. 不再以键值对的形式存储数据，而是直接存储数据的值；
   2. 容器内部存储的各个元素的值都互不相等，且不能被修改。
   3. 不会对内部存储的数据进行排序（这和该容器底层采用哈希表结构存储数据有关

   

   
